Abstraction over equations | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Havoc supports universal abstraction; that is, basically anything can be generated from an equation. As such, you can create equations that imply or equate to other equations in Havoc, and use
this to save typing. For example:

| symmetric f = (f x y = f y x ∀ x and y) ∀ f
  symmetric (+)                                 / <- equivalent to writing the symmetry equation

Higher-order abstraction.
You can write equations that generate equation generators too. Because equation quantities are abstract, this means that you can disassemble expressions before they are evaluated. For example:

| f x = f x         ← f = debug g  ∀ f and x
        debug f $ x ↤

This rewrites regular function applications into debugging ones. This works because Havoc will always take a matching equivalence.

Anonymous equivalence.
Sometimes you want to specify a symbol or function without naming it. In a lot of languages you'd create an anonymous function and pass that in, but those languages often have trouble with
piecewise function definition in this context. In Havoc, the only anonymous equations are those which quantify all of their variables (such as the debugging equation above). The usual protocol
for working around this is to pass in an equation that binds the underscore. For example:

| map (_ x = x + 1 ∀ x) xs

The map function could be written this way:

| map f xs = _ h : map f t ← h : t = xs  ⋅ f  ∀ f and xs
             xs            ↤
