Internal syntax representation | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Havoc syntax is represented in terms of n-ary tree nodes, just like Caterwaul. However, Havoc source trees are different in a few ways. For one thing, all parentheses are implied; there is no
parenthesis node. The reason is that operator precedence is well-defined and invariant at runtime. While it is possible to redefine operator precedence through rewriting, it isn't possible to
introduce new operators that have undetermined precedence.

Interpreter implementation.
There are two aspects of the interpreter that are less than obvious. First is how ambiguity sets are implemented, and second is how scopes are implemented.

  Ambiguity sets.
  Every symbol defined in every scope is annotated with an ambiguity-set gensym. Ambiguity set gensyms are erased for quantified variables (that is, variables whose scope is bounded by ∀)
  because quantified variables would never use them. So toplevel definitions are translated like this:

  | f x = x + 1 ∀ x             -> (quote $ f × gensym_10412) (var $ x) = (operator +) (var $ x) (number 1)
    f x = x + 2 ∀ x             -> (quote $ f × gensym_10419) (var $ x) = (operator +) (var $ x) (number 2)

  This is almost all that's necessary. The only other thing is to find all references to the global 'f' and annotate them with gensyms. This can happen either at compile-time or at runtime,
  depending on whether it's possible to specialize early. If at compile-time, then the nodes are linked then; otherwise the nodes are annotated with a link to a discriminant that determines
  which alternative to use.

  Scopes.
  Scopes aren't particularly challenging.
