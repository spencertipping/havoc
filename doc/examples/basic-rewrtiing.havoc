Basic rewriting example | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Havoc is a generalization of lambda calculus to terms of arbitrary form. That is, it performs algebraic pattern-matching on values and uses relations as transformation rules. This is a
generalization of lambda calculus because it permits alternative evaluation orders depending on external constraints. For example, suppose we introduce these equivalences:

| f $ number x = number x + 1 ⋅ f 5 = 6
  string x = parse_number $ string x ⋅ "45" = 45 and f "45" = 46

If we then say 'f "48"', we'll get 49 because of the equivalence between strings and numbers. The reason for this is that 49 is more concrete than 'f "48"'. There's a bigger philosophical
problem with what's going on here, though, and that's that the order of function application is generally well-defined from inside to outside (unless you're in Haskell). What is the order of
evaluation in Havoc?

The answer is that it's whatever satisfies the programmer's constraints. These constraints are specified using the 'wh' operator (short for 'where'), which is also written '⋅'. This operator
reduces the set of possible behaviors of a construct by specifying a local invariant.

Complex patterns.
The patterns in the example above are fairly trivial, but patterns in general don't have to be. Here's a case where you can use Havoc to solve simple equations:

| op x y = op y x ∀ op ∈ {(+), (*)}                                                     / Commutativity
  op x (op y z) = op (op x y) z ∀ op ∈ {(+), (*)}                                       / Associativity
  x * (y + z) = x * y + x * z                                                           / Distributivity
  x - (y - z) = x - y + z                                                               / Help with negation
  x + 0 = x                                                                             / Additive identity
  x * 1 = x                                                                             / Multiplicative identity
  x ^ number n = x * x ^ (number n - 1)                                                 / Definition of exponentiation
  x ^ 1 = x
  x ^ 0 = 1
  (x = y) = (x - y = 0)                                                                 / Identity of addition
  (a * x ^ 2 + b * x + c = 0) = (x = (0 - b + sqrt (b ^ 2 + 4 * a * c)) / 2 * a or      / Quadratic formula
                                 x = (0 - b - sqrt (b ^ 2 + 4 * a * c)) / 2 * a)

Havoc already gives you enough to make = into a mathematical equivalence relation:

| x = x                                                                                 / Reflexivity of =, already assumed by Havoc
  (x = y) = (y = x)                                                                     / Symmetry of =, already assumed by Havoc
  (x = y and y = z) → (x = z)                                                           / Transitivity of =, already assumed by Havoc

At this point you can constrain the value of 'z' by doing this:

| 5 * z ^ 2 - 10 * z = 400

Havoc will rewrite the equation to subtract 400 from both sides, then use the quadratic formula to end up with two possibilities from which to proceed. If you further constrain the value of z,
then possibilities will be eliminated. Even more interesting is what happens when you do something like this:

| 5 * (z + 1) ^ 2 - 10 * z = 400

Havoc can use the distributive property in reverse (with your suggestion; the compiler would take forever to figure this out on its own) to construct these intermediate equations:

| 5 * (z + 1) ^ 2 - (10 * z + 10 * 1 - 10 * 1) = 400
  5 * (z + 1) ^ 2 - (10 * (z + 1) - 10) = 400
  5 * (z + 1) ^ 2 - 10 * (z + 1) + 10 = 400
  5 * (z + 1) ^ 2 - 10 * (z + 1) - 390 = 0              / Quadratic formula can happen here

The important things about complex patterns are:

| 1. You can do algebraic unification by reusing a variable, as we did above with the quadratic formula.
  2. Patterns on each side of an equality can be arbitrarily complex.
