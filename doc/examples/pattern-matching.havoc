Pattern matching example | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Functional languages often use pattern matching to indicate which of several paths to take. Havoc is no different, though its pattern matching is first-class. This means that you can compose
patterns and match clauses with each other using abstraction. For example:

depth $ empty             = 0
depth $ tree :left :right = 1 + max $ depth left $ depth right âˆ‹ depth $ tree empty empty = 1

The 'tree' data constructor is allowed here because it is used; there is no need to define it. In fact, every tagged data structure is simply an undefined function applied to one or more
arguments. You can then pattern-match on these function applications. Because of this relationship, you can then define the function to establish isomorphism. For instance, suppose we wanted
to create an isomorphism between trees and linked lists:

empty      = nil
tree :l :r = cons l r

Now we can apply list functions to trees:

length $ tree 5 $ tree 6 empty          / Returns 2
