Redefining primitives | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Don't do this. Don't do any of it. Everything mentioned here will break Havoc in significant ways, and your programs will either fail to do what you want or will cause Havoc's compiler to
infinite-loop.

Redefining equality.
The = operator is first-class, so you can create alternatives for it. For example:

| (x = y) = (x + 1 = y + 1) ∀ x and y

This causes Havoc to add one to each side of an equation. The trouble is that Havoc will do this indefinitely because it has no reason to stop. Worse, it may recognize the divergent nature of
'=' and assign arbitrary values to your equations. So don't do this.

If you want to create alternative equality relations, you can define custom operators that end in =. For example:

| (x == y) = (x + 1 = y + 1) ∀ x and y

This will do what you want. == has the same precedence and associativity as =, since they both end with the same thing. However, there is now no ambiguity about the meaning of =; this still
unambiguously refers to Havoc's = primitive.

Redefining quantifiers.
This is another thing you can do but shouldn't:

| (x ∀ y) = (x + 1 ∀ y) ∀ x and y

Like before, this will loop indefinitely or assign arbitrary values to quantified expressions. You can create your own quantifiers, however, by ending an operator with ∀ or ∃:

| (x +1∀ y) = (x + 1 ∀ y) ∀ x and y

Redefining scoping.
Finally, you can redefine the scoping operator at your peril:

| (x ⋅ y) = (x + 1 ⋅ y)

If you want to do it safely:

| (x +1⋅ y) = (x + 1 ⋅ y)
