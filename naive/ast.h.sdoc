Havoc abstract syntax tree | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Havoc's syntax trees are just linked lists for the purposes of this implementation. The only significant difference is that they're first converted to integers to make comparisons faster.

#ifndef __HAVOC_AST_H
#define __HAVOC_AST_H

#include <iostream>
#include <map>
#include <string>
#include <utility>

using namespace std;

namespace havoc {

static int next_free_value = 0;
static map<string, int> encoding_table;
static map<int, string> decoding_table;

int encode_internal (string &token, bool variable, bool is_gensym) {
  if (encoding_table.count(token) && ! is_gensym) return encoding_table[token];
  int key = variable ? -++next_free_value : ++next_free_value;
  decoding_table[key] = token;
  return is_gensym ? key : (encoding_table[token] = key);
}

static int constant_literal (string &name) { return encode_internal(name, false, false); }
static int variable_literal (string &name) { return encode_internal(name, true,  false); }
static int gensym_forsome   (string &name) { return encode_internal(name, false, true);  }
static int gensym_forall    (string &name) { return encode_internal(name, true,  true);  }

Types of values.
There are two main types of values in Havoc, and those are cons cells and atoms. Cons cells are represented as pointers, and literals are represented as integers whose value is shifted one bit
to the left to add a '1' marker bit. Unlike Lisps, Havoc's lists are improper. This means that a single-element list is identical to the element itself, which preserves the notational
intuition that (x) == x âˆ€ x.

typedef long long int value_t;
typedef pair<value_t, value_t> cons_t;

static value_t atom (int value)            { return value << 1 | 1; }
static value_t cons (value_t h, value_t t) { return reinterpret_cast<value_t>(new cons_t(h, t)); }

static bool consp (value_t value)   { return ! (value & 1); }
static value_t head (value_t value) { return reinterpret_cast<cons_t*>(value)->first; }
static value_t tail (value_t value) { return reinterpret_cast<cons_t*>(value)->second; }

static ostream &print_value (ostream &s, value_t v) {
  if (consp(v)) {
    s << "(";
    while (consp(v)) print_value(s, head(v)) << " ", v = tail(v);
    s << v << ")";
  } else {
    s << decoding_table[v >> 1];
  }
  return s;
}

}

#endif
