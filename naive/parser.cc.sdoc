Basic Havoc parser | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
This is just about the simplest possible way to parse something. We split on spaces and newlines; each newline signals the beginning of a new equation, and each space signals the beginning of
a new token. Each token is then encoded and consed into a list of some sort. This parser handles all forms of Havoc comment syntax.

#include <string>
#include <vector>

#include <boost/tuple/tuple.hpp>

#include "ast.h"

using namespace std;
using namespace boost;

namespace havoc {
namespace {

template<typename T>
struct parse_state : public tuple<const string&, int, T> {
 public:
  parse_state(const string &input, int position, T value) : tuple<const string&, int, T>(input, position, value) {}
  virtual ~parse_state () {}

  const string &input() const { return this->get<0>(); }
  int position()        const { return this->get<1>(); }
  T value()             const { return this->get<2>(); }

  parse_state<T> *accept (int size) {
    return new parse_state<T>(input(), position() + size, input().substr(position(), size));
  }
};

template<typename T, typename U>
class parser_base {
 public:
  virtual ~parser_base () {}

  // Returns a maybe parse state. If successful, returns a new parse state that
  // advances the position through the string. If unsuccessful, returns NULL.
  virtual parse_state<U> *operator() (parse_state<T> &s) = 0;
};

template<typename T, typename U>
class character_class : public parser_base<T, U> {
 public:
  character_class (const char *accepted) {
    for (int i = 0; i < 256; ++i) accepts[i] = false;
    for (const char *c = accepted; *c; ++c) accepts[*c] = true;
  }

  virtual ~character_class () { delete[] accepts; }

  virtual parse_state<U> *operator() (parse_state<T> &s) {
    unsigned int p = s.position();
    while (p < s.input().size() && accepts[s.input()[p]]) ++p;
    return s.accept(p - s.position());
  }

 private:
  bool accepts[256];
};

static const character_class<const string&, const string&> whitespace(" \n\t");

}

}
