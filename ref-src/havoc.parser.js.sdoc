Havoc reference implementation parser | Author name
Licensed under the terms of the MIT source code license

Introduction.
Havoc is a relatively straightforward language to parse. Tokens are separated either by parentheses or whitespace, and each line is separate. Paren and other groups form cons lists (no
significance is assigned to which kind of group delimiter you use). SDoc-style literate comments are supported and removed, as well as line comments. This is done during a pre-parse lexing
phase.

caterwaul.js_all()(function ($) {

Havoc syntax.
Since this is the reference implementation, I'm going to provide a complete listing of Havoc's syntactic constructs here. First, there are various types of comments, all of which are removed
by the lexer. These include literate paragraphs, which follow SDoc syntax, and line comments, which come in several different styles:

| foo bar bif           # line comment                  <- two or more spaces between code and the #
  foo bar bif           - line comment                  <- ditto here
  foo bar bif           / line comment
  foo bar bif           Line comment                    <- capital letter indicates line comment, but only after two or more spaces
  Line comment                                          <- no spaces required if no code is present
  # line comment
  - line comment
  / line comment

This syntax was chosen to be ergonomic (hence the capital letter heuristic and the choice of - and /), and to allow traditional constructs like the shebang line. I make no claim that you'd
want to use shebang-style interpretation without a memoizing interpreter ... but the syntax won't prevent you from doing so.

Operators.
My initial inclination was to use lists to represent all expressions. However, lists suck (in my very biased opinion). So, Havoc doesn't try to make lists out of stuff you write. Instead, it
folds your code into a right-associative syntax tree, where it infers operators based on the first character of each symbol. Operators include a motley assortment of characters I decided
should be operators; the reference implementation isn't necessarily to spec about this.

Note that function application always has higher precedence than operators. You can rewrite expressions to change this, but the parse considers function application to be the
highest-precedence thing that can happen.

Atoms.
There are two kinds of atoms. One is a literal or operator, which doesn't start with a letter, and the other is a variable, which does. This is backwards from Caterwaul's convention that
variables start with an underscore, but Havoc is biased towards abstraction rather than constants. The convention in Havoc is to begin literal words with a single quotation mark, as in Lisp.
So, for example:

| 'fact n = n > 0 ? 'fact (n - 1) : 1

This is obviously not the same notation used in the files in doc/. The reference implementation differs from the ideal on this point.

  $.havoc.parse(s) = s /!without_comments /!split_into_lists

             -where [without_comments(s) = s.split(/\n\s*\n/) %![/^\s*[A-Z|]/.test(x)] -seq -re- it.join('\n').replace(/(^\s*|\s\s+)[-\/#A-Z].*$/mg, ''),

                     split_into_lists(s) = [new linear_string_state(s)] /!toplevel -re- it[0].value()

                                   -where [toplevel(ss) = toplevel(ss), toplevel = annotate(toplevel, 'toplevel'),

                                           wsr(regexp)           = linear_regexp(/\s+/) /!optional /-bfs/ linear_regexp(regexp),

                                           symbol                = wsr(/[0-9a-zA-Z_'][^\n\t ,;()\[\]\{\}]*/) /-map/ "_[0] /!syntax.symbol".qf,
                                           operator              = wsr(             /[^\n\t ,;()\[\]\{\}]+/) /-map/ "_[0] /!syntax.symbol".qf,
                                           operator_literal      = wsr(/\(/) / operator /-bfc/ wsr(/\)/)     /-map/ "_[1]".qf,
                                           list(o, c)            = wsr(o)    / toplevel /-bfc/ wsr(c)        /-map/ "_[1]".qf,
                                           paren_list            = list(/\(/, /\)/),
                                           bracket_list          = list(/\[/, /\]/),
                                           brace_list            = list(/\{/, /\}/),

                                           atom                  = operator_literal / paren_list / bracket_list / brace_list /-alt/ symbol,

                                           delimited(p, s, cons) = p /-bfc/ manyc(s /-bfc/ p) /-map/ "_[1] /[_[0]][x0 /-cons/ x] -seq".qf /-alt/ p,
                                           application           = atom /!manyc /-map/ "_ /[x0 /-syntax.application/ x] -seq".qf,
                                           infix_tree            = delimited(application, operator, syntax.infix(y[0].data, x, y[1]) -given [x, y]),
                                           comma_list            = delimited(infix_tree,  wsr(/,/), syntax.comma(x, y[1])            -given [x, y]),
                                           toplevel              = comma_list]

                                   -using- caterwaul.parser
                                   -using- caterwaul.havoc]})(caterwaul);
